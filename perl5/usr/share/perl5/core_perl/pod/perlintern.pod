-*- buffer-read-only: t -*-

!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by autodoc.pl extracting documentation from the C source
files.

=head1 NAME

perlintern - autogenerated documentation of purely B<internal>
		 Perl functions

=head1 DESCRIPTION
X<internal Perl functions> X<interpreter functions>

This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API. In other words,
B<they are not for use in extensions>!


=head1 CV reference counts and CvOUTSIDE

=over 8

=item CvWEAKOUTSIDE
X<CvWEAKOUTSIDE>

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any). Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us. In this case, we set the
C<CvWEAKOUTSIDE> flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>. In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

	bool	CvWEAKOUTSIDE(CV *cv)

=for hackers
Found in file cv.h


=back

=head1 Functions in file pad.h


=over 8

=item CX_CURPAD_SAVE
X<CX_CURPAD_SAVE>

Save the current pad in the given context block structure.

	void	CX_CURPAD_SAVE(struct context)

=for hackers
Found in file pad.h

=item CX_CURPAD_SV
X<CX_CURPAD_SV>

Access the SV at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).

	SV *	CX_CURPAD_SV(struct context, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_BASE_SV
X<PAD_BASE_SV>

Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

	SV *	PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_CLONE_VARS
X<PAD_CLONE_VARS>

Clone the state variables associated with running and compiling pads.

	void	PAD_CLONE_VARS(PerlInterpreter *proto_perl, CLONE_PARAMS* param)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_FLAGS
X<PAD_COMPNAME_FLAGS>

Return the flags for the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

	U32	PAD_COMPNAME_FLAGS(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN
X<PAD_COMPNAME_GEN>

The generation number of the name at offset C<po> in the current
compiling pad (lvalue). Note that C<SvUVX> is hijacked for this purpose.

	STRLEN	PAD_COMPNAME_GEN(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN_set
X<PAD_COMPNAME_GEN_set>

Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.  Note that C<SvUV_set> is hijacked for this purpose.

	STRLEN	PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_OURSTASH
X<PAD_COMPNAME_OURSTASH>

Return the stash associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

	HV *	PAD_COMPNAME_OURSTASH(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_PV
X<PAD_COMPNAME_PV>

Return the name of the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

	char *	PAD_COMPNAME_PV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_TYPE
X<PAD_COMPNAME_TYPE>

Return the type (stash) of the current compiling pad name at offset
C<po>. Must be a valid name. Returns null if not typed.

	HV *	PAD_COMPNAME_TYPE(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_DUP
X<PAD_DUP>

Clone a padlist.

	void	PAD_DUP(PADLIST dstpad, PADLIST srcpad, CLONE_PARAMS* param)

=for hackers
Found in file pad.h

=item PAD_RESTORE_LOCAL
X<PAD_RESTORE_LOCAL>

Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()

	void	PAD_RESTORE_LOCAL(PAD *opad)

=for hackers
Found in file pad.h

=item PAD_SAVE_LOCAL
X<PAD_SAVE_LOCAL>

Save the current pad to the local variable opad, then make the
current pad equal to npad

	void	PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

=for hackers
Found in file pad.h

=item PAD_SAVE_SETNULLPAD
X<PAD_SAVE_SETNULLPAD>

Save the current pad then set it to null.

	void	PAD_SAVE_SETNULLPAD()

=for hackers
Found in file pad.h

=item PAD_SETSV
X<PAD_SETSV>

Set the slot at offset C<po> in the current pad to C<sv>

	SV *	PAD_SETSV(PADOFFSET po, SV* sv)

=for hackers
Found in file pad.h

=item PAD_SET_CUR
X<PAD_SET_CUR>

Set the current pad to be pad C<n> in the padlist, saving
the previous current pad. NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


	void	PAD_SET_CUR(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SET_CUR_NOSAVE
X<PAD_SET_CUR_NOSAVE>

like PAD_SET_CUR, but without the save

	void	PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SV
X<PAD_SV>

Get the value at offset C<po> in the current pad

	void	PAD_SV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_SVl
X<PAD_SVl>

Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

	SV *	PAD_SVl(PADOFFSET po)

=for hackers
Found in file pad.h

=item SAVECLEARSV
X<SAVECLEARSV>

Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')

	void	SAVECLEARSV(SV **svp)

=for hackers
Found in file pad.h

=item SAVECOMPPAD
X<SAVECOMPPAD>

save PL_comppad and PL_curpad





	void	SAVECOMPPAD()

=for hackers
Found in file pad.h

=item SAVEPADSV
X<SAVEPADSV>

Save a pad slot (used to restore after an iteration)

XXX DAPM it would make more sense to make the arg a PADOFFSET
	void	SAVEPADSV(PADOFFSET po)

=for hackers
Found in file pad.h


=back

=head1 Functions in file pp_ctl.c


=over 8

=item docatch
X<docatch>

Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.

0 is used as continue inside eval,

3 is used for a die caught by an inner eval - continue inner loop

See cop.h: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
establish a local jmpenv to handle exception traps.

	OP*	docatch(OP *o)

=for hackers
Found in file pp_ctl.c


=back

=head1 GV Functions

=over 8

=item gv_try_downgrade
X<gv_try_downgrade>

If the typeglob C<gv> can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that C<gv>
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.

If C<gv> is a completely empty typeglob, it is deleted from the stash.

If C<gv> is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.

NOTE: this function is experimental and may change or be
removed without notice.

	void	gv_try_downgrade(GV* gv)

=for hackers
Found in file gv.c

=item is_gv_magical_sv
X<is_gv_magical_sv>

Returns C<TRUE> if given the name of a magical GV.

Currently only useful internally when determining if a GV should be
created even in rvalue contexts.

C<flags> is not used at present but available for future extension to
allow selecting particular classes of magical variable.

Currently assumes that C<name> is NUL terminated (as well as len being valid).
This assumption is met by all callers within the perl core, which all pass
pointers returned by SvPV.

	bool	is_gv_magical_sv(SV *const name_sv, U32 flags)

=for hackers
Found in file gv.c


=back

=head1 Hash Manipulation Functions

=over 8

=item refcounted_he_chain_2hv
X<refcounted_he_chain_2hv>

Generates and returns a C<HV *> by walking up the tree starting at the passed
in C<struct refcounted_he *>.

NOTE: this function is experimental and may change or be
removed without notice.

	HV *	refcounted_he_chain_2hv(const struct refcounted_he *c)

=for hackers
Found in file hv.c

=item refcounted_he_free
X<refcounted_he_free>

Decrements the reference count of the passed in C<struct refcounted_he *>
by one. If the reference count reaches zero the structure's memory is freed,
and C<refcounted_he_free> iterates onto the parent node.

NOTE: this function is experimental and may change or be
removed without notice.

	void	refcounted_he_free(struct refcounted_he *he)

=for hackers
Found in file hv.c

=item refcounted_he_new
X<refcounted_he_new>

Creates a new C<struct refcounted_he>. As S<key> is copied, and value is
stored in a compact form, all references remain the property of the caller.
The C<struct refcounted_he> is returned with a reference count of 1.

NOTE: this function is experimental and may change or be
removed without notice.

	struct refcounted_he *	refcounted_he_new(struct refcounted_he *const parent, SV *const key, SV *const value)

=for hackers
Found in file hv.c


=back

=head1 IO Functions

=over 8

=item start_glob
X<start_glob>

Function called by C<do_readline> to spawn a glob (or do the glob inside
perl on VMS). This code used to be inline, but now perl uses C<File::Glob>
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.

NOTE: this function is experimental and may change or be
removed without notice.

	PerlIO*	start_glob(SV *tmpglob, IO *io)

=for hackers
Found in file doio.c


=back

=head1 Magical Functions

=over 8

=item magic_clearhint
X<magic_clearhint>

Triggered by a delete from %^H, records the key to
C<PL_compiling.cop_hints_hash>.

	int	magic_clearhint(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item magic_clearhints
X<magic_clearhints>

Triggered by clearing %^H, resets C<PL_compiling.cop_hints_hash>.

	int	magic_clearhints(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item magic_sethint
X<magic_sethint>

Triggered by a store to %^H, records the key/value pair to
C<PL_compiling.cop_hints_hash>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.

	int	magic_sethint(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item mg_localize
X<mg_localize>

Copy some of the magic from an existing SV to new localized version of that
SV. Container magic (eg %ENV, $1, tie) gets copied, value magic doesn't (eg
taint, pos).

If setmagic is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. 'local $x = $y'),
and that will handle the magic.

	void	mg_localize(SV* sv, SV* nsv, bool setmagic)

=for hackers
Found in file mg.c


=back

=head1 MRO Functions

=over 8

=item mro_get_linear_isa_dfs
X<mro_get_linear_isa_dfs>

Returns the Depth-First Search linearization of @ISA
the given stash.  The return value is a read-only AV*.
C<level> should be 0 (it is used internally in this
function's recursion).

You are responsible for C<SvREFCNT_inc()> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).

	AV*	mro_get_linear_isa_dfs(HV* stash, U32 level)

=for hackers
Found in file mro.c

=item mro_isa_changed_in
X<mro_isa_changed_in>

Takes the necessary steps (cache invalidations, mostly)
when the @ISA of the given package has changed.  Invoked
by the C<setisa> magic, should not need to invoke directly.

	void	mro_isa_changed_in(HV* stash)

=for hackers
Found in file mro.c


=back

=head1 Pad Data Structures

=over 8

=item CvPADLIST
X<CvPADLIST>

CV's can have CvPADLIST(cv) set to point to an AV.

For these purposes "forms" are a kind-of CV, eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing). Require'd files are simply evals without any outer lexical
scope.

XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).

The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in pad.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:

0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.

The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @_.
other entries are storage for variables and op targets.

During compilation:
C<PL_comppad_name> is set to the names AV.
C<PL_comppad> is set to the frame AV for the frame CvDEPTH == 1.
C<PL_curpad> is set to the body of the frame AV (i.e. AvARRAY(PL_comppad)).

During execution, C<PL_comppad> and C<PL_curpad> refer to the live
frame of the currently executing sub.

Iterating over the names AV iterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef "names" (see pad_alloc()).

Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" like
my/our variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in PL_op->op_targ), wasting a name SV for them doesn't make sense.

The SVs in the names AV have their PV being the name of the variable.
xlow+1..xhigh inclusive in the NV union is a range of cop_seq numbers for
which the name is valid.  For typed lexicals name SV is SVt_PVMG and SvSTASH
points at the type.  For C<our> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate C<our> declarations in the same package can be detected).  SvUVX is
sometimes hijacked to store the generation number during compilation.

If SvFAKE is set on the name SV, then that slot in the frame AV is
a REFCNT'ed reference to a lexical from "outside". In this case,
the name SV does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, xlow contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.

If the 'name' is '&' the corresponding entry in frame AV
is a CV representing a possible closure.
(SvFAKE and name of '&' is not a meaningful combination currently but could
become so if C<my sub foo {}> is implemented.)

Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).

The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed,
and set on scope exit. This allows the 'Variable $x is not available' warning
to be generated in evals, such as 

    { my $x = 1; sub f { eval '$x'} } f();

For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised'

	AV *	CvPADLIST(CV *cv)

=for hackers
Found in file pad.c

=item cv_clone
X<cv_clone>

Clone a CV: make a new CV which points to the same code etc, but which
has a newly-created pad built by copying the prototype pad and capturing
any outer lexicals.

	CV*	cv_clone(CV* proto)

=for hackers
Found in file pad.c

=item cv_dump
X<cv_dump>

dump the contents of a CV

	void	cv_dump(const CV *cv, const char *title)

=for hackers
Found in file pad.c

=item do_dump_pad
X<do_dump_pad>

Dump the contents of a padlist

	void	do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist, int full)

=for hackers
Found in file pad.c

=item intro_my
X<intro_my>

"Introduce" my variables to visible status.

	U32	intro_my()

=for hackers
Found in file pad.c

=item pad_add_anon
X<pad_add_anon>

Add an anon code entry to the current compiling pad

	PADOFFSET	pad_add_anon(SV* sv, OPCODE op_type)

=for hackers
Found in file pad.c

=item pad_add_name
X<pad_add_name>

Create a new name and associated PADMY SV in the current pad; return the
offset.
If C<typestash> is valid, the name is for a typed lexical; set the
name's stash to that value.
If C<ourstash> is valid, it's an our lexical, set the name's
SvOURSTASH to that value

If fake, it means we're cloning an existing entry

NOTE: this function is experimental and may change or be
removed without notice.

	PADOFFSET	pad_add_name(const char *name, const STRLEN len, const U32 flags, HV *typestash, HV *ourstash)

=for hackers
Found in file pad.c

=item pad_alloc
X<pad_alloc>

Allocate a new my or tmp pad entry. For a my, simply push a null SV onto
the end of PL_comppad, but for a tmp, scan the pad from PL_padix upwards
for a slot which has no name and no active value.

	PADOFFSET	pad_alloc(I32 optype, U32 tmptype)

=for hackers
Found in file pad.c

=item pad_block_start
X<pad_block_start>

Update the pad compilation state variables on entry to a new block

	void	pad_block_start(int full)

=for hackers
Found in file pad.c

=item pad_check_dup
X<pad_check_dup>

Check for duplicate declarations: report any of:
     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the same stash
       as C<ourstash>
C<is_our> indicates that the name to check is an 'our' declaration

	void	pad_check_dup(SV *name, const U32 flags, const HV *ourstash)

=for hackers
Found in file pad.c

=item pad_findlex
X<pad_findlex>

Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
cv is the CV in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the IVX field of a fake namesv.

Note that pad_findlex() is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.

	PADOFFSET	pad_findlex(const char *name, const CV* cv, U32 seq, int warn, SV** out_capture, SV** out_name_sv, int *out_flags)

=for hackers
Found in file pad.c

=item pad_fixup_inner_anons
X<pad_fixup_inner_anons>

For any anon CVs in the pad, change CvOUTSIDE of that CV from
old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.

	void	pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv, CV *new_cv)

=for hackers
Found in file pad.c

=item pad_free
X<pad_free>

Free the SV at offset po in the current pad.

	void	pad_free(PADOFFSET po)

=for hackers
Found in file pad.c

=item pad_leavemy
X<pad_leavemy>

Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.

	void	pad_leavemy()

=for hackers
Found in file pad.c

=item pad_new
X<pad_new>

Create a new compiling padlist, saving and updating the various global
vars at the same time as creating the pad itself. The following flags
can be OR'ed together:

    padnew_CLONE	this pad is for a cloned CV
    padnew_SAVE		save old globals
    padnew_SAVESUB	also save extra stuff for start of sub

	PADLIST*	pad_new(int flags)

=for hackers
Found in file pad.c

=item pad_push
X<pad_push>

Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an @_ in slot zero.

	void	pad_push(PADLIST *padlist, int depth)

=for hackers
Found in file pad.c

=item pad_reset
X<pad_reset>

Mark all the current temporaries for reuse

	void	pad_reset()

=for hackers
Found in file pad.c

=item pad_setsv
X<pad_setsv>

Set the entry at offset po in the current pad to sv.
Use the macro PAD_SETSV() rather than calling this function directly.

	void	pad_setsv(PADOFFSET po, SV* sv)

=for hackers
Found in file pad.c

=item pad_swipe
X<pad_swipe>

Abandon the tmp in the current pad at offset po and replace with a
new one.

	void	pad_swipe(PADOFFSET po, bool refadjust)

=for hackers
Found in file pad.c

=item pad_tidy
X<pad_tidy>

Tidy up a pad after we've finished compiling it:
    * remove most stuff from the pads of anonsub prototypes;
    * give it a @_;
    * mark tmps as such.

	void	pad_tidy(padtidy_type type)

=for hackers
Found in file pad.c

=item pad_undef
X<pad_undef>

Free the padlist associated with a CV.
If parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we don't have any dangling references left.
We also repoint the CvOUTSIDE of any about-to-be-orphaned
inner subs to the outer of this cv.

(This function should really be called pad_free, but the name was already
taken)

	void	pad_undef(CV* cv)

=for hackers
Found in file pad.c


=back

=head1 Per-Interpreter Variables

=over 8

=item PL_DBsingle
X<PL_DBsingle>

When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<PL_DBsub>.

	SV *	PL_DBsingle

=for hackers
Found in file intrpvar.h

=item PL_DBsub
X<PL_DBsub>

When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<PL_DBsingle>.

	GV *	PL_DBsub

=for hackers
Found in file intrpvar.h

=item PL_DBtrace
X<PL_DBtrace>

Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<PL_DBsingle>.

	SV *	PL_DBtrace

=for hackers
Found in file intrpvar.h

=item PL_dowarn
X<PL_dowarn>

The C variable which corresponds to Perl's $^W warning variable.

	bool	PL_dowarn

=for hackers
Found in file intrpvar.h

=item PL_last_in_gv
X<PL_last_in_gv>

The GV which was last used for a filehandle input operation. (C<< <FH> >>)

	GV*	PL_last_in_gv

=for hackers
Found in file intrpvar.h

=item PL_ofsgv
X<PL_ofsgv>

The glob containing the output field separator - C<*,> in Perl space.

	GV*	PL_ofsgv

=for hackers
Found in file intrpvar.h

=item PL_rs
X<PL_rs>

The input record separator - C<$/> in Perl space.

	SV*	PL_rs

=for hackers
Found in file intrpvar.h


=back

=head1 Stack Manipulation Macros

=over 8

=item djSP
X<djSP>

Declare Just C<SP>. This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)

		djSP;

=for hackers
Found in file pp.h

=item LVRET
X<LVRET>

True if this op will be the return value of an lvalue subroutine

=for hackers
Found in file pp.h


=back

=head1 SV Manipulation Functions

=over 8

=item sv_add_arena
X<sv_add_arena>

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

	void	sv_add_arena(char *const ptr, const U32 size, const U32 flags)

=for hackers
Found in file sv.c

=item sv_clean_all
X<sv_clean_all>

Decrement the refcnt of each remaining SV, possibly triggering a
cleanup. This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.

	I32	sv_clean_all()

=for hackers
Found in file sv.c

=item sv_clean_objs
X<sv_clean_objs>

Attempt to destroy all objects not yet freed

	void	sv_clean_objs()

=for hackers
Found in file sv.c

=item sv_free_arenas
X<sv_free_arenas>

Deallocate the memory used by all arenas. Note that all the individual SV
heads and bodies within the arenas must already have been freed.

	void	sv_free_arenas()

=for hackers
Found in file sv.c


=back

=head1 SV-Body Allocation

=over 8

=item sv_2num
X<sv_2num>

Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  You must use the C<SvNUM(sv)> macro to
access this function.

NOTE: this function is experimental and may change or be
removed without notice.

	SV*	sv_2num(SV *const sv)

=for hackers
Found in file sv.c


=back

=head1 Unicode Support

=over 8

=item find_uninit_var
X<find_uninit_var>

Find the name of the undefined variable (if any) that caused the operator o
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if it's value matches uninit_sv.
So roughly speaking, if a unary operator (such as OP_COS) generates a
warning, then following the direct child of the op may yield an
OP_PADSV or OP_GV that gives the name of the undefined variable. On the
other hand, with OP_ADD there are two branches to follow, so we only print
the variable name if we get an exact match.

The name is returned as a mortal SV.

Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.

NOTE: this function is experimental and may change or be
removed without notice.

	SV*	find_uninit_var(const OP *const obase, const SV *const uninit_sv, bool top)

=for hackers
Found in file sv.c

=item report_uninit
X<report_uninit>

Print appropriate "Use of uninitialized variable" warning

	void	report_uninit(const SV *uninit_sv)

=for hackers
Found in file sv.c


=back

=head1 Undocumented functions

These functions are currently undocumented:

=over

=item F0convert
X<F0convert>

=item Slab_to_rw
X<Slab_to_rw>

=item add_data
X<add_data>

=item add_utf16_textfilter
X<add_utf16_textfilter>

=item addmad
X<addmad>

=item allocmy
X<allocmy>

=item amagic_cmp
X<amagic_cmp>

=item amagic_cmp_locale
X<amagic_cmp_locale>

=item amagic_i_ncmp
X<amagic_i_ncmp>

=item amagic_ncmp
X<amagic_ncmp>

=item anonymise_cv
X<anonymise_cv>

=item ao
X<ao>

=item append_elem
X<append_elem>

=item append_list
X<append_list>

=item append_madprops
X<append_madprops>

=item apply
X<apply>

=item apply_attrs
X<apply_attrs>

=item apply_attrs_my
X<apply_attrs_my>

=item av_reify
X<av_reify>

=item bad_type
X<bad_type>

=item bind_match
X<bind_match>

=item block_end
X<block_end>

=item block_start
X<block_start>

=item boot_core_PerlIO
X<boot_core_PerlIO>

=item boot_core_UNIVERSAL
X<boot_core_UNIVERSAL>

=item boot_core_mro
X<boot_core_mro>

=item bytes_to_uni
X<bytes_to_uni>

=item cando
X<cando>

=item check_type_and_open
X<check_type_and_open>

=item check_uni
X<check_uni>

=item checkcomma
X<checkcomma>

=item checkposixcc
X<checkposixcc>

=item ck_anoncode
X<ck_anoncode>

=item ck_bitop
X<ck_bitop>

=item ck_concat
X<ck_concat>

=item ck_defined
X<ck_defined>

=item ck_delete
X<ck_delete>

=item ck_die
X<ck_die>

=item ck_each
X<ck_each>

=item ck_eof
X<ck_eof>

=item ck_eval
X<ck_eval>

=item ck_exec
X<ck_exec>

=item ck_exists
X<ck_exists>

=item ck_exit
X<ck_exit>

=item ck_ftst
X<ck_ftst>

=item ck_fun
X<ck_fun>

=item ck_glob
X<ck_glob>

=item ck_grep
X<ck_grep>

=item ck_index
X<ck_index>

=item ck_join
X<ck_join>

=item ck_lfun
X<ck_lfun>

=item ck_listiob
X<ck_listiob>

=item ck_match
X<ck_match>

=item ck_method
X<ck_method>

=item ck_null
X<ck_null>

=item ck_open
X<ck_open>

=item ck_readline
X<ck_readline>

=item ck_repeat
X<ck_repeat>

=item ck_require
X<ck_require>

=item ck_return
X<ck_return>

=item ck_rfun
X<ck_rfun>

=item ck_rvconst
X<ck_rvconst>

=item ck_sassign
X<ck_sassign>

=item ck_select
X<ck_select>

=item ck_shift
X<ck_shift>

=item ck_sort
X<ck_sort>

=item ck_spair
X<ck_spair>

=item ck_split
X<ck_split>

=item ck_subr
X<ck_subr>

=item ck_substr
X<ck_substr>

=item ck_svconst
X<ck_svconst>

=item ck_trunc
X<ck_trunc>

=item ck_unpack
X<ck_unpack>

=item ckwarn_common
X<ckwarn_common>

=item cl_and
X<cl_and>

=item cl_anything
X<cl_anything>

=item cl_init
X<cl_init>

=item cl_init_zero
X<cl_init_zero>

=item cl_is_anything
X<cl_is_anything>

=item cl_or
X<cl_or>

=item clear_placeholders
X<clear_placeholders>

=item closest_cop
X<closest_cop>

=item convert
X<convert>

=item cop_free
X<cop_free>

=item cr_textfilter
X<cr_textfilter>

=item create_eval_scope
X<create_eval_scope>

=item curmad
X<curmad>

=item cv_ckproto_len
X<cv_ckproto_len>

=item deb_curcv
X<deb_curcv>

=item deb_stack_all
X<deb_stack_all>

=item deb_stack_n
X<deb_stack_n>

=item debprof
X<debprof>

=item debug_start_match
X<debug_start_match>

=item del_sv
X<del_sv>

=item delete_eval_scope
X<delete_eval_scope>

=item deprecate_commaless_var_list
X<deprecate_commaless_var_list>

=item destroy_matcher
X<destroy_matcher>

=item die_where
X<die_where>

=item div128
X<div128>

=item do_aexec
X<do_aexec>

=item do_aexec5
X<do_aexec5>

=item do_chomp
X<do_chomp>

=item do_chop
X<do_chop>

=item do_delete_local
X<do_delete_local>

=item do_eof
X<do_eof>

=item do_exec
X<do_exec>

=item do_exec3
X<do_exec3>

=item do_execfree
X<do_execfree>

=item do_ipcctl
X<do_ipcctl>

=item do_ipcget
X<do_ipcget>

=item do_kv
X<do_kv>

=item do_msgrcv
X<do_msgrcv>

=item do_msgsnd
X<do_msgsnd>

=item do_oddball
X<do_oddball>

=item do_op_xmldump
X<do_op_xmldump>

=item do_pmop_xmldump
X<do_pmop_xmldump>

=item do_print
X<do_print>

=item do_readline
X<do_readline>

=item do_seek
X<do_seek>

=item do_semop
X<do_semop>

=item do_shmio
X<do_shmio>

=item do_smartmatch
X<do_smartmatch>

=item do_sysseek
X<do_sysseek>

=item do_tell
X<do_tell>

=item do_trans
X<do_trans>

=item do_trans_complex
X<do_trans_complex>

=item do_trans_complex_utf8
X<do_trans_complex_utf8>

=item do_trans_count
X<do_trans_count>

=item do_trans_count_utf8
X<do_trans_count_utf8>

=item do_trans_simple
X<do_trans_simple>

=item do_trans_simple_utf8
X<do_trans_simple_utf8>

=item do_vecget
X<do_vecget>

=item do_vecset
X<do_vecset>

=item do_vop
X<do_vop>

=item doeval
X<doeval>

=item dofile
X<dofile>

=item dofindlabel
X<dofindlabel>

=item doform
X<doform>

=item dooneliner
X<dooneliner>

=item doopen_pm
X<doopen_pm>

=item doparseform
X<doparseform>

=item dopoptoeval
X<dopoptoeval>

=item dopoptogiven
X<dopoptogiven>

=item dopoptolabel
X<dopoptolabel>

=item dopoptoloop
X<dopoptoloop>

=item dopoptosub_at
X<dopoptosub_at>

=item dopoptowhen
X<dopoptowhen>

=item dump_all_perl
X<dump_all_perl>

=item dump_exec_pos
X<dump_exec_pos>

=item dump_packsubs_perl
X<dump_packsubs_perl>

=item dump_sub_perl
X<dump_sub_perl>

=item dump_sv_child
X<dump_sv_child>

=item dump_trie
X<dump_trie>

=item dump_trie_interim_list
X<dump_trie_interim_list>

=item dump_trie_interim_table
X<dump_trie_interim_table>

=item dumpuntil
X<dumpuntil>

=item dup_attrlist
X<dup_attrlist>

=item emulate_cop_io
X<emulate_cop_io>

=item exec_failed
X<exec_failed>

=item expect_number
X<expect_number>

=item feature_is_enabled
X<feature_is_enabled>

=item filter_gets
X<filter_gets>

=item find_and_forget_pmops
X<find_and_forget_pmops>

=item find_array_subscript
X<find_array_subscript>

=item find_beginning
X<find_beginning>

=item find_byclass
X<find_byclass>

=item find_hash_subscript
X<find_hash_subscript>

=item find_in_my_stash
X<find_in_my_stash>

=item find_script
X<find_script>

=item first_symbol
X<first_symbol>

=item fold_constants
X<fold_constants>

=item forbid_setid
X<forbid_setid>

=item force_ident
X<force_ident>

=item force_list
X<force_list>

=item force_next
X<force_next>

=item force_strict_version
X<force_strict_version>

=item force_version
X<force_version>

=item force_word
X<force_word>

=item forget_pmop
X<forget_pmop>

=item free_tied_hv_pool
X<free_tied_hv_pool>

=item gen_constant_list
X<gen_constant_list>

=item get_arena
X<get_arena>

=item get_aux_mg
X<get_aux_mg>

=item get_db_sub
X<get_db_sub>

=item get_debug_opts
X<get_debug_opts>

=item get_hash_seed
X<get_hash_seed>

=item get_isa_hash
X<get_isa_hash>

=item get_no_modify
X<get_no_modify>

=item get_num
X<get_num>

=item get_opargs
X<get_opargs>

=item get_re_arg
X<get_re_arg>

=item getenv_len
X<getenv_len>

=item glob_2number
X<glob_2number>

=item glob_assign_glob
X<glob_assign_glob>

=item glob_assign_ref
X<glob_assign_ref>

=item group_end
X<group_end>

=item gv_ename
X<gv_ename>

=item gv_get_super_pkg
X<gv_get_super_pkg>

=item gv_init_sv
X<gv_init_sv>

=item hfreeentries
X<hfreeentries>

=item hsplit
X<hsplit>

=item hv_auxinit
X<hv_auxinit>

=item hv_backreferences_p
X<hv_backreferences_p>

=item hv_copy_hints_hv
X<hv_copy_hints_hv>

=item hv_delete_common
X<hv_delete_common>

=item hv_kill_backrefs
X<hv_kill_backrefs>

=item hv_magic_check
X<hv_magic_check>

=item hv_notallowed
X<hv_notallowed>

=item incline
X<incline>

=item incpush
X<incpush>

=item incpush_if_exists
X<incpush_if_exists>

=item incpush_use_sep
X<incpush_use_sep>

=item ingroup
X<ingroup>

=item init_argv_symbols
X<init_argv_symbols>

=item init_dbargs
X<init_dbargs>

=item init_debugger
X<init_debugger>

=item init_ids
X<init_ids>

=item init_interp
X<init_interp>

=item init_main_stash
X<init_main_stash>

=item init_perllib
X<init_perllib>

=item init_postdump_symbols
X<init_postdump_symbols>

=item init_predump_symbols
X<init_predump_symbols>

=item intuit_method
X<intuit_method>

=item intuit_more
X<intuit_more>

=item invert
X<invert>

=item io_close
X<io_close>

=item is_an_int
X<is_an_int>

=item is_handle_constructor
X<is_handle_constructor>

=item is_inplace_av
X<is_inplace_av>

=item is_list_assignment
X<is_list_assignment>

=item is_utf8_X_L
X<is_utf8_X_L>

=item is_utf8_X_LV
X<is_utf8_X_LV>

=item is_utf8_X_LVT
X<is_utf8_X_LVT>

=item is_utf8_X_LV_LVT_V
X<is_utf8_X_LV_LVT_V>

=item is_utf8_X_T
X<is_utf8_X_T>

=item is_utf8_X_V
X<is_utf8_X_V>

=item is_utf8_X_begin
X<is_utf8_X_begin>

=item is_utf8_X_extend
X<is_utf8_X_extend>

=item is_utf8_X_non_hangul
X<is_utf8_X_non_hangul>

=item is_utf8_X_prepend
X<is_utf8_X_prepend>

=item is_utf8_char_slow
X<is_utf8_char_slow>

=item is_utf8_common
X<is_utf8_common>

=item isa_lookup
X<isa_lookup>

=item jmaybe
X<jmaybe>

=item join_exact
X<join_exact>

=item keyword
X<keyword>

=item keyword_plugin_standard
X<keyword_plugin_standard>

=item lex_end
X<lex_end>

=item lex_start
X<lex_start>

=item linklist
X<linklist>

=item list
X<list>

=item listkids
X<listkids>

=item localize
X<localize>

=item looks_like_bool
X<looks_like_bool>

=item lop
X<lop>

=item mad_free
X<mad_free>

=item madlex
X<madlex>

=item madparse
X<madparse>

=item magic_clear_all_env
X<magic_clear_all_env>

=item magic_clearenv
X<magic_clearenv>

=item magic_clearisa
X<magic_clearisa>

=item magic_clearpack
X<magic_clearpack>

=item magic_clearsig
X<magic_clearsig>

=item magic_existspack
X<magic_existspack>

=item magic_freearylen_p
X<magic_freearylen_p>

=item magic_freeovrld
X<magic_freeovrld>

=item magic_get
X<magic_get>

=item magic_getarylen
X<magic_getarylen>

=item magic_getdefelem
X<magic_getdefelem>

=item magic_getnkeys
X<magic_getnkeys>

=item magic_getpack
X<magic_getpack>

=item magic_getpos
X<magic_getpos>

=item magic_getsig
X<magic_getsig>

=item magic_getsubstr
X<magic_getsubstr>

=item magic_gettaint
X<magic_gettaint>

=item magic_getuvar
X<magic_getuvar>

=item magic_getvec
X<magic_getvec>

=item magic_killbackrefs
X<magic_killbackrefs>

=item magic_len
X<magic_len>

=item magic_methcall
X<magic_methcall>

=item magic_methpack
X<magic_methpack>

=item magic_nextpack
X<magic_nextpack>

=item magic_regdata_cnt
X<magic_regdata_cnt>

=item magic_regdatum_get
X<magic_regdatum_get>

=item magic_regdatum_set
X<magic_regdatum_set>

=item magic_scalarpack
X<magic_scalarpack>

=item magic_set
X<magic_set>

=item magic_set_all_env
X<magic_set_all_env>

=item magic_setamagic
X<magic_setamagic>

=item magic_setarylen
X<magic_setarylen>

=item magic_setcollxfrm
X<magic_setcollxfrm>

=item magic_setdbline
X<magic_setdbline>

=item magic_setdefelem
X<magic_setdefelem>

=item magic_setenv
X<magic_setenv>

=item magic_setisa
X<magic_setisa>

=item magic_setmglob
X<magic_setmglob>

=item magic_setnkeys
X<magic_setnkeys>

=item magic_setpack
X<magic_setpack>

=item magic_setpos
X<magic_setpos>

=item magic_setregexp
X<magic_setregexp>

=item magic_setsig
X<magic_setsig>

=item magic_setsubstr
X<magic_setsubstr>

=item magic_settaint
X<magic_settaint>

=item magic_setutf8
X<magic_setutf8>

=item magic_setuvar
X<magic_setuvar>

=item magic_setvec
X<magic_setvec>

=item magic_sizepack
X<magic_sizepack>

=item magic_wipepack
X<magic_wipepack>

=item make_matcher
X<make_matcher>

=item make_trie
X<make_trie>

=item make_trie_failtable
X<make_trie_failtable>

=item malloc_good_size
X<malloc_good_size>

=item malloced_size
X<malloced_size>

=item matcher_matches_sv
X<matcher_matches_sv>

=item measure_struct
X<measure_struct>

=item mem_collxfrm
X<mem_collxfrm>

=item mem_log_common
X<mem_log_common>

=item mess_alloc
X<mess_alloc>

=item method_common
X<method_common>

=item missingterm
X<missingterm>

=item mod
X<mod>

=item mode_from_discipline
X<mode_from_discipline>

=item modkids
X<modkids>

=item more_bodies
X<more_bodies>

=item more_sv
X<more_sv>

=item mro_meta_dup
X<mro_meta_dup>

=item mro_meta_init
X<mro_meta_init>

=item mul128
X<mul128>

=item mulexp10
X<mulexp10>

=item my_attrs
X<my_attrs>

=item my_betoh16
X<my_betoh16>

=item my_betoh32
X<my_betoh32>

=item my_betoh64
X<my_betoh64>

=item my_betohi
X<my_betohi>

=item my_betohl
X<my_betohl>

=item my_betohs
X<my_betohs>

=item my_clearenv
X<my_clearenv>

=item my_exit_jump
X<my_exit_jump>

=item my_htobe16
X<my_htobe16>

=item my_htobe32
X<my_htobe32>

=item my_htobe64
X<my_htobe64>

=item my_htobei
X<my_htobei>

=item my_htobel
X<my_htobel>

=item my_htobes
X<my_htobes>

=item my_htole16
X<my_htole16>

=item my_htole32
X<my_htole32>

=item my_htole64
X<my_htole64>

=item my_htolei
X<my_htolei>

=item my_htolel
X<my_htolel>

=item my_htoles
X<my_htoles>

=item my_kid
X<my_kid>

=item my_letoh16
X<my_letoh16>

=item my_letoh32
X<my_letoh32>

=item my_letoh64
X<my_letoh64>

=item my_letohi
X<my_letohi>

=item my_letohl
X<my_letohl>

=item my_letohs
X<my_letohs>

=item my_swabn
X<my_swabn>

=item my_unexec
X<my_unexec>

=item need_utf8
X<need_utf8>

=item newDEFSVOP
X<newDEFSVOP>

=item newGIVWHENOP
X<newGIVWHENOP>

=item newGP
X<newGP>

=item newMADPROP
X<newMADPROP>

=item newMADsv
X<newMADsv>

=item newTOKEN
X<newTOKEN>

=item new_constant
X<new_constant>

=item new_he
X<new_he>

=item new_logop
X<new_logop>

=item new_warnings_bitfield
X<new_warnings_bitfield>

=item next_symbol
X<next_symbol>

=item nextargv
X<nextargv>

=item nextchar
X<nextchar>

=item no_bareword_allowed
X<no_bareword_allowed>

=item no_fh_allowed
X<no_fh_allowed>

=item no_op
X<no_op>

=item not_a_number
X<not_a_number>

=item nuke_stacks
X<nuke_stacks>

=item num_overflow
X<num_overflow>

=item offer_nice_chunk
X<offer_nice_chunk>

=item oopsAV
X<oopsAV>

=item oopsHV
X<oopsHV>

=item op_clear
X<op_clear>

=item op_const_sv
X<op_const_sv>

=item op_getmad
X<op_getmad>

=item op_getmad_weak
X<op_getmad_weak>

=item op_refcnt_dec
X<op_refcnt_dec>

=item op_refcnt_inc
X<op_refcnt_inc>

=item op_xmldump
X<op_xmldump>

=item open_script
X<open_script>

=item opt_scalarhv
X<opt_scalarhv>

=item pack_rec
X<pack_rec>

=item package
X<package>

=item package_version
X<package_version>

=item pad_add_name_sv
X<pad_add_name_sv>

=item pad_compname_type
X<pad_compname_type>

=item pad_peg
X<pad_peg>

=item parse_body
X<parse_body>

=item parse_unicode_opts
X<parse_unicode_opts>

=item parser_free
X<parser_free>

=item path_is_absolute
X<path_is_absolute>

=item peep
X<peep>

=item pending_Slabs_to_ro
X<pending_Slabs_to_ro>

=item pidgone
X<pidgone>

=item pm_description
X<pm_description>

=item pmflag
X<pmflag>

=item pmop_xmldump
X<pmop_xmldump>

=item pmruntime
X<pmruntime>

=item pmtrans
X<pmtrans>

=item prepend_elem
X<prepend_elem>

=item prepend_madprops
X<prepend_madprops>

=item printbuf
X<printbuf>

=item process_special_blocks
X<process_special_blocks>

=item ptr_table_find
X<ptr_table_find>

=item put_byte
X<put_byte>

=item qerror
X<qerror>

=item qsortsvu
X<qsortsvu>

=item re_croak2
X<re_croak2>

=item readpipe_override
X<readpipe_override>

=item ref_array_or_hash
X<ref_array_or_hash>

=item refcounted_he_fetch
X<refcounted_he_fetch>

=item refcounted_he_new_common
X<refcounted_he_new_common>

=item refcounted_he_value
X<refcounted_he_value>

=item refkids
X<refkids>

=item refto
X<refto>

=item reg
X<reg>

=item reg_check_named_buff_matched
X<reg_check_named_buff_matched>

=item reg_named_buff
X<reg_named_buff>

=item reg_named_buff_iter
X<reg_named_buff_iter>

=item reg_namedseq
X<reg_namedseq>

=item reg_node
X<reg_node>

=item reg_numbered_buff_fetch
X<reg_numbered_buff_fetch>

=item reg_numbered_buff_length
X<reg_numbered_buff_length>

=item reg_numbered_buff_store
X<reg_numbered_buff_store>

=item reg_qr_package
X<reg_qr_package>

=item reg_recode
X<reg_recode>

=item reg_scan_name
X<reg_scan_name>

=item reg_skipcomment
X<reg_skipcomment>

=item reg_temp_copy
X<reg_temp_copy>

=item reganode
X<reganode>

=item regatom
X<regatom>

=item regbranch
X<regbranch>

=item regclass
X<regclass>

=item regcppop
X<regcppop>

=item regcppush
X<regcppush>

=item regcurly
X<regcurly>

=item regdump_extflags
X<regdump_extflags>

=item reghop3
X<reghop3>

=item reghop4
X<reghop4>

=item reghopmaybe3
X<reghopmaybe3>

=item reginclass
X<reginclass>

=item reginsert
X<reginsert>

=item regmatch
X<regmatch>

=item regpiece
X<regpiece>

=item regpposixcc
X<regpposixcc>

=item regprop
X<regprop>

=item regrepeat
X<regrepeat>

=item regtail
X<regtail>

=item regtail_study
X<regtail_study>

=item regtry
X<regtry>

=item reguni
X<reguni>

=item regwhite
X<regwhite>

=item report_evil_fh
X<report_evil_fh>

=item require_tie_mod
X<require_tie_mod>

=item restore_magic
X<restore_magic>

=item rsignal_restore
X<rsignal_restore>

=item rsignal_save
X<rsignal_save>

=item run_body
X<run_body>

=item run_user_filter
X<run_user_filter>

=item rxres_free
X<rxres_free>

=item rxres_restore
X<rxres_restore>

=item rxres_save
X<rxres_save>

=item same_dirent
X<same_dirent>

=item save_freeop
X<save_freeop>

=item save_hek_flags
X<save_hek_flags>

=item save_hints
X<save_hints>

=item save_lines
X<save_lines>

=item save_magic
X<save_magic>

=item save_op
X<save_op>

=item save_pushi32ptr
X<save_pushi32ptr>

=item save_pushptri32ptr
X<save_pushptri32ptr>

=item save_pushptrptr
X<save_pushptrptr>

=item save_scalar_at
X<save_scalar_at>

=item sawparens
X<sawparens>

=item scalar
X<scalar>

=item scalar_mod_type
X<scalar_mod_type>

=item scalarboolean
X<scalarboolean>

=item scalarkids
X<scalarkids>

=item scalarseq
X<scalarseq>

=item scalarvoid
X<scalarvoid>

=item scan_commit
X<scan_commit>

=item scan_const
X<scan_const>

=item scan_formline
X<scan_formline>

=item scan_heredoc
X<scan_heredoc>

=item scan_ident
X<scan_ident>

=item scan_inputsymbol
X<scan_inputsymbol>

=item scan_pat
X<scan_pat>

=item scan_str
X<scan_str>

=item scan_subst
X<scan_subst>

=item scan_trans
X<scan_trans>

=item scan_word
X<scan_word>

=item scope
X<scope>

=item search_const
X<search_const>

=item sequence
X<sequence>

=item sequence_num
X<sequence_num>

=item sequence_tail
X<sequence_tail>

=item share_hek_flags
X<share_hek_flags>

=item sighandler
X<sighandler>

=item simplify_sort
X<simplify_sort>

=item skipspace
X<skipspace>

=item skipspace0
X<skipspace0>

=item skipspace1
X<skipspace1>

=item skipspace2
X<skipspace2>

=item softref2xv
X<softref2xv>

=item sortcv
X<sortcv>

=item sortcv_stacked
X<sortcv_stacked>

=item sortcv_xsub
X<sortcv_xsub>

=item space_join_names_mortal
X<space_join_names_mortal>

=item start_force
X<start_force>

=item stdize_locale
X<stdize_locale>

=item store_cop_label
X<store_cop_label>

=item strip_return
X<strip_return>

=item study_chunk
X<study_chunk>

=item sub_crush_depth
X<sub_crush_depth>

=item sublex_done
X<sublex_done>

=item sublex_push
X<sublex_push>

=item sublex_start
X<sublex_start>

=item sv_2iuv_common
X<sv_2iuv_common>

=item sv_2iuv_non_preserve
X<sv_2iuv_non_preserve>

=item sv_add_backref
X<sv_add_backref>

=item sv_catxmlpvn
X<sv_catxmlpvn>

=item sv_catxmlsv
X<sv_catxmlsv>

=item sv_del_backref
X<sv_del_backref>

=item sv_dup_inc_multiple
X<sv_dup_inc_multiple>

=item sv_exp_grow
X<sv_exp_grow>

=item sv_free2
X<sv_free2>

=item sv_i_ncmp
X<sv_i_ncmp>

=item sv_kill_backrefs
X<sv_kill_backrefs>

=item sv_ncmp
X<sv_ncmp>

=item sv_pos_b2u_midway
X<sv_pos_b2u_midway>

=item sv_pos_u2b_cached
X<sv_pos_u2b_cached>

=item sv_pos_u2b_forwards
X<sv_pos_u2b_forwards>

=item sv_pos_u2b_midway
X<sv_pos_u2b_midway>

=item sv_release_COW
X<sv_release_COW>

=item sv_setsv_cow
X<sv_setsv_cow>

=item sv_unglob
X<sv_unglob>

=item sv_xmlpeek
X<sv_xmlpeek>

=item swallow_bom
X<swallow_bom>

=item swash_get
X<swash_get>

=item to_byte_substr
X<to_byte_substr>

=item to_utf8_substr
X<to_utf8_substr>

=item token_free
X<token_free>

=item token_getmad
X<token_getmad>

=item tokenize_use
X<tokenize_use>

=item tokeq
X<tokeq>

=item tokereport
X<tokereport>

=item too_few_arguments
X<too_few_arguments>

=item too_many_arguments
X<too_many_arguments>

=item uiv_2buf
X<uiv_2buf>

=item unpack_rec
X<unpack_rec>

=item unshare_hek
X<unshare_hek>

=item unshare_hek_or_pvn
X<unshare_hek_or_pvn>

=item unwind_handler_stack
X<unwind_handler_stack>

=item update_debugger_info
X<update_debugger_info>

=item usage
X<usage>

=item utf16_textfilter
X<utf16_textfilter>

=item utf8_mg_pos_cache_update
X<utf8_mg_pos_cache_update>

=item utilize
X<utilize>

=item validate_suid
X<validate_suid>

=item varname
X<varname>

=item vdie
X<vdie>

=item vdie_common
X<vdie_common>

=item vdie_croak_common
X<vdie_croak_common>

=item visit
X<visit>

=item vivify_defelem
X<vivify_defelem>

=item vivify_ref
X<vivify_ref>

=item wait4pid
X<wait4pid>

=item watch
X<watch>

=item write_no_mem
X<write_no_mem>

=item write_to_stderr
X<write_to_stderr>

=item xmldump_all
X<xmldump_all>

=item xmldump_all_perl
X<xmldump_all_perl>

=item xmldump_attr
X<xmldump_attr>

=item xmldump_eval
X<xmldump_eval>

=item xmldump_form
X<xmldump_form>

=item xmldump_indent
X<xmldump_indent>

=item xmldump_packsubs
X<xmldump_packsubs>

=item xmldump_packsubs_perl
X<xmldump_packsubs_perl>

=item xmldump_sub
X<xmldump_sub>

=item xmldump_sub_perl
X<xmldump_sub_perl>

=item xmldump_vindent
X<xmldump_vindent>

=item yyerror
X<yyerror>

=item yylex
X<yylex>

=item yyparse
X<yyparse>

=item yywarn
X<yywarn>

=back


=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

L<perlguts>, L<perlapi>

=cut

 ex: set ro:
